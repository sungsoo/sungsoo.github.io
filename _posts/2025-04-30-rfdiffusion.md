---
layout: post
title: Design of Protein Structure with RFdiffusion  
date: 2025-04-30
categories: [artificial intelligence]
tags: [artificial general intelligence]

---

### Article Source


* [Design of Protein Structure with RFdiffusion](https://www.youtube.com/watch?v=agiHi6hOE3Q)

---

# [Design of Protein Structure with RFdiffusion](https://www.youtube.com/watch?v=agiHi6hOE3Q)

This week we discuss RFDiffusion[1] a diffusion denoising model based on RoseTTAFold to generate realistic protein protein backbones. Nick Randolf gives an overview of the method and we discuss the method details.

* slides: [https://bit.ly/46Terw4](https://bit.ly/46Terw4)
* codes: [https://github.com/RosettaCommons/RFdiffusion](https://github.com/RosettaCommons/RFdiffusion)

[1] *De novo design of protein structure and function with RFdiffusion*

Joseph L. Watson, David Juergens, Nathaniel R. Bennett, Brian L. Trippe, Jason Yim, Helen E. Eisenach, Woody Ahern, Andrew J. Borst, Robert J. Ragotte, Lukas F. Milles, Basile I. M. Wicky, Nikita Hanikel, Samuel J. Pellock, Alexis Courbet, William Sheffler, Jue Wang, Preetham Venkatesh, Isaac Sappington, Susana Vázquez Torres, Anna Lauko, Valentin De Bortoli, Emile Mathieu, Sergey Ovchinnikov, Regina Barzilay, Tommi S. Jaakkola, Frank DiMaio, Minkyung Baek & David Baker
Nature 620, 1089–1100 (2023).

## 주요 내용

이 세미나는 분자 모델링 분야의 최신 연구 동향을 소개하며, 특히 베이커 연구실에서 개발한 단백질 구조 생성 모델인 **RF Diffusion**에 대해 심층적으로 논의합니다. 주요 핵심 내용은 다음과 같습니다.

### **1. RF Diffusion 모델 개요:**

* RF Diffusion은 RosettaFold를 기반으로 구축된 확산 모델(Diffusion Model)로, 단백질 백본 구조 생성을 목표로 합니다.
* 기존 단백질 구조 예측 모델(RosettaFold, AlphaFold)과는 달리, 단백질 서열 정보 없이도 백본 구조를 생성할 수 있습니다.
* FrameDiff와 유사하게 단백질 잔기를 SE(3) 다양체의 요소(회전 행렬과 병진 벡터)로 표현하고, 이 다양체 상에서 확산 및 역확산 과정을 수행합니다.

### **2. FrameDiff와의 유사점 및 차이점:**

| 특징             | FrameDiff                               | RF Diffusion                             |
| ---------------- | --------------------------------------- | ---------------------------------------- |
| **주요 목표** | 단백질 백본 생성                          | 단백질 백본 생성                           |
| **입력 정보** | (주로) 초기 노이즈                       | (주로) 초기 노이즈 (선택적으로 추가 정보 활용) |
| **단백질 표현** | SE(3) 다양체 기반 잔기 표현                | SE(3) 다양체 기반 잔기 표현                 |
| **확산 공간** | SE(3) 다양체 (SO(3) 및 병진 독립적 확산) | SE(3) 다양체 (SO(3) 및 병진 독립적 확산) |
| **모델 아키텍처** | SE(3) 등변성 유지하는 어텐션 및 트랜스포머 | SE(3) 등변성 유지하는 어텐션 및 트랜스포머 |
| **손실 함수** | 이론적 기반의 Denoising Score Matching | 경험적 기반의 평균 제곱 오차 (MSE)        |
| **사전 학습** | 없음                                    | RosettaFold의 사전 학습된 가중치 활용 및 Fine-tuning |

### **3. 백본 생성 과정:**

* 초기에는 가우시안 분포의 병진 벡터와 균일 분포의 회전 행렬로 이루어진 노이즈 잔기 분포에서 샘플링합니다.
* 학습 과정에서는 실제 단백질 구조에 노이즈를 점진적으로 추가하고, 이를 역전시키는(Denoising) 과정을 학습합니다.
* 역확산 과정은 여러 단계(예: 200단계)를 거쳐 점진적으로 노이즈를 제거하며, 각 단계에서 RosettaFold 모델을 사용하여 Denoised된 구조를 예측하고 보간(Interpolation)합니다.
* Self-conditioning 기법을 사용하여 이전 단계에서 예측된 구조 정보를 모델 입력에 다시 활용합니다.

### **4. 모델 아키텍처 (RosettaFold 활용):**

* RF Diffusion은 RosettaFold 2의 아키텍처를 기반으로 합니다.
* RosettaFold는 MSA(Multiple Sequence Alignment) 트랙, Pair 트랙, 3D 트랙의 세 가지 트랙을 사용하여 단백질 구조를 예측합니다.
* RF Diffusion에서는 서열 정보가 마스크 처리되므로 MSA 트랙의 입력은 마스크 토큰으로 채워집니다.
* Self-conditioning을 통해 얻은 예측 구조로부터 Pair 특징(Distogram, Anglogram)을 계산하여 Pair 트랙의 입력으로 사용합니다.
* 확산된 좌표는 3D 트랙의 입력으로 사용됩니다.
* RosettaFold와 달리 RF Diffusion에서는 Recycling 과정이 사용되지 않습니다.

### **5. 확장 기능:**

* **대칭 구조 생성:** 노이즈 분포를 대칭화하여 대칭적인 단백질 구조를 생성할 수 있습니다.
* **결합 부위 특이적 결합체 디자인:** 특정 결합 부위(Hotspot 잔기 지정)에 결합하는 단백질을 디자인할 수 있습니다.
* **모티프 스캐폴딩:** 특정 기능성 모티프를 유지하면서 주변 스캐폴드 구조를 디자인할 수 있습니다.
* **대칭 모티프 스캐폴딩:** 대칭적인 모티프를 유지하면서 대칭적인 스캐폴드 구조를 디자인할 수 있습니다.

### **6. 학습 및 구현 세부 사항 (보충 자료 기반):**

* RosettaFold는 SE(3) 등변성 레이어, 어텐션 메커니즘 등을 사용하여 좌표를 업데이트하고, 곁사슬 비틀림 각 및 산소 원자 위치를 예측합니다.
* RosettaFold 학습에는 FAPE 손실, 비틀림 각 손실, 결합 거리 및 방향 손실 등 다양한 손실 함수가 사용됩니다.
* RF Diffusion은 RosettaFold의 사전 학습된 가중치를 활용하여 Fine-tuning 방식으로 학습됩니다.
* RF Diffusion의 역확산 과정은 회전과 병진에 대해 독립적으로 파라미터화됩니다.

### **결론:**

이 세미나는 RF Diffusion이 단백질 구조 생성 분야에서 보여주는 혁신적인 가능성을 강조합니다. 특히 서열 정보 없이도 구조를 생성하고, 다양한 조건 및 제약 사항을 통합하여 특정 기능을 갖는 단백질을 디자인할 수 있다는 점이 주목할 만합니다. RosettaFold의 강력한 구조 예측 능력을 기반으로 구축된 RF Diffusion은 향후 신약 개발, 생체 재료 디자인 등 다양한 분야에 기여할 것으로 기대됩니다.

<iframe width="600" height="400" src="https://www.youtube.com/embed/agiHi6hOE3Q?si=XRStS_tPX1l1XsUb" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>


## 세부 발표 내용

네, 시작해도 좋을 것 같습니다. 죄송합니다. 다른 마이크를 사용하겠습니다.

네, 여러분, 환영합니다. 분자 ML 회의의 또 다른 세션에 참석해 주셔서 감사합니다. 오늘 저희는 베이커 연구실에서 나온 매우 흥미로운 논문에 대해 이야기할 것입니다.

RF 확산에 관한 것이며, 많은 분들이 이 모델이나 최소한 RosettaFold를 기반으로 구축된 네트워크에 대해 들어보셨을 것이라고 확신합니다. 하지만 저희는 이 네트워크의 구체적인 내용과 학습 방법, 그리고 적용된 몇 가지 확장 기능에 대해 자세히 알아볼 것입니다.

하지만 그 전에, 늘 그렇듯이 몇 가지 준비 사항부터 시작하겠습니다. 다시 한번 말씀드리지만, 저희는 2주마다 회의를 가질 예정이며, 다음 회의는 오늘로부터 2주 후인 10월 2일에 있을 예정입니다.

그 회의에는 제가 참석할 수 없어서, 발표를 하거나 저희가 논의하고 있는 내용과 관련된 특정 작업에 대해 이야기할 의향이 있거나 관심 있는 다른 분들에게 기회가 열려 있습니다. 관심 있으신 분은 저에게 연락해 주십시오. 그렇지 않으면 저희가 다른 방안을 찾거나 일정을 변경할 것입니다. 그러니 관심 있으신 분은 저에게 연락해 주십시오.

그 아톰 기반의 RF 확산 모델이 어제 나왔는데, 2주 후에 이야기해 볼 만한 주제일 수도 있겠네요. 어떻게 생각하시나요? 또한,

음, 포켓 플로우라는 모델도 있는데, RF 확산이나 DiffDock 그룹과 비슷한 그룹에서 나왔습니다. 이 두 가지 모두 재미있게 다룰 수 있을 것 같습니다. 음, 저는 여기 있을 것 같고, 다른 분들이 하나 또는 두 가지 모두에 대해 이야기하고 싶어 하신다면 기꺼이 진행을 돕겠습니다.

굉장하네요. 슬랙에서... 네, 네, 저희가 알아서 하겠습니다. 좋습니다. 늘 그렇듯이, 논문을 선택하는 구글 폼이 있습니다. 다음 회의는 조금 다를 것이기 때문에 그다지 관련은 없지만, 아마도 모든 원자 확산이나 맷이 방금 제안한 포켓 관련 내용에 대해 이야기할 것입니다. 하지만 평소와는 조금 다르게, 저희는 논문을 좀 더 기초적인 내용과 응용 기반의 내용으로 분리할 예정입니다. 그렇게 하면 모델의 기초에 대해 더 배우고 싶어 하는 분들은 그 내용을 자세히 살펴보고 이론을 쌓아나갈 수 있을 것입니다. 좋습니다. 오늘 저희는 RF 확산에 대해 이야기할 것이고, 이것은 지난 세션과 정말 좋은 연결고리가 됩니다. 왜냐하면 저희는 FrameDiff에 대해 이야기했고, 이 두 모델은 매우 관련이 깊기 때문입니다. 그리고 저는 이 표에서 그들의 유사점과 차이점을 매우 간략하게 강조한 다음, 구체적인 내용으로 들어가기 전에 전체 방법에 대한 개요를 조금 더 설명할 것입니다. 하지만 말씀드린 것처럼, 이 두 가지는 매우 유사한 방법이며, 작업 수준에서 둘 다 단백질 백본을 생성하는 동일한 목표를 달성하고 있습니다. RosettaFold 또는 RF 확산(죄송합니다)은 때로는 원하시면 약간의 추가 정보를 사용하지만, 주로 둘 다 단백질 백본 생성을 위한 것입니다. 그들은 단백질과 잔기를 동일한 방식으로 표현합니다. 따라서 각 잔기는 실제로 SE(3)의 요소이며, 이는 저희가 지난주나 2주 전에 이야기했던 다양체이며, 회전 행렬과 병진 벡터로 구성된 강체 변환 T로 이루어져 있습니다. 따라서 이 두 가지 방법 모두 이러한 강체 프레임을 잔기로 사용합니다. 그리고 이 때문에 둘 다 동일한 다양체 상에서 확산됩니다. 즉, 둘 다 SE(3) 상에서 확산되며, 실제로 SO(3)(3차원 공간에서의 회전 행렬 그룹) 상에서의 확산과 병진 벡터로 분해합니다. 따라서 이것은 가우시안 확산이고, 이것은 이것에 대한 균일 확산이 될 것입니다. 따라서 그들은 그 측면에서 매우 유사합니다. 아키텍처 측면에서는 약간 다르지만, 둘 다 동일한 속성, 즉 SE(3) 등변성을 유지합니다. 약간 다르지만, 전반적으로 그들은 어텐션과 트랜스포머를 사용하여 모델을 표현합니다. 주요 차이점 중 하나는 손실 함수이며, 이것은 우리가 자세한 내용으로 들어가면서 더 많이 보게 될 것입니다. 따라서 FrameDiff에서 저희가 구축한 것처럼, 그들은 좀 더 이론적인 디노이징 스코어 매칭 손실을 사용합니다. 그리고 이것은 실제로 데이터와 일치시키기 위해 이동해야 하는 방향과 일치시키려고 노력하는 것입니다. 하지만 RFD Fusion은 좀 더 경험적인 방법을 사용하며, 이는 평균 제곱 오차를 기반으로 합니다. 그리고 그들은 이에 대한 몇 가지 정당성을 가지고 있으며, 저희는 나중에 그것에 대해 조금 더 자세히 살펴볼 것입니다. 하지만 손실 함수는 다릅니다. 따라서 FrameDiff는 더 이론적이고, AR 확산은 더 경험적 기반이지만, 둘 다 매우 잘 작동합니다. 그리고 또 다른 주요 차이점은 사전 학습입니다. FrameDiff에서는 사전 학습이 없었기 때문에 전혀 언급하지 않았지만, RosettaFold 확산은 RosettaFold 위에 구축되었습니다. 따라서 RosettaFold에서 사전 학습된 가중치를 사용한 다음, 실제 확산 프로세스를 위해 이를 확장하고 미세 조정합니다.

자, 백본 생성 과정의 개요를 조금 살펴보겠습니다. 이것은 논문의 그림이지만, 아이디어는 저희가 노이즈가 있는 잔기에 대한 좋은 사전 분포를 가지고 있고, 그것들을 단백질 구조로 디노이징하고 싶다는 것입니다. 그리고 이것은 실제 단백질 구조를 가져와 노이징한 다음, 그 역과정을 학습함으로써 훈련됩니다. 따라서 저희는 확산에 대해 조금 이야기했으므로, 이 내용에 대해 꽤 익숙하실 것입니다. 이 프레임이 실제로 어떻게 구성되는지 말씀드리고 싶습니다. 왜냐하면 저는 그것이 매우 흥미롭다고 생각하고, 어떻게 수행되는지 명확하지 않기 때문입니다. 하지만 이것은 제가 이전에 이 내용을 강조하기 위해 만든 그림입니다. 따라서 제가 언급한 것처럼 각 프레임 T는 회전과 병진으로 구성됩니다. 병진 벡터는 실제로 C 알파가 있는 위치입니다. 따라서 여기에 어떤 종류의 전역 좌표계 X, Y, Z가 있다면, 저희는 실제로 C 알파를 가리키는 이 병진 벡터만 가지고 있습니다. 따라서 정말 간단합니다. 따라서 저희는 이 병진 벡터에 대한 좌표를 가지고 있지만, 회전 행렬은 조금 더 복잡하며, 이 백본의 방향에 해당합니다. 제가 의미하는 바는, 저희가 이 전역 프레임을 가지고 있고, 그것을 이것의 맨 위에 놓고 C 알파-C 결합과 정렬하면, 보시다시피 이것으로 이것을 회전시키면 이 변환 행렬이 생깁니다. 따라서 본질적으로 여러분이 하는 것은 이 C 알파-C 결합을 이 x축과 정렬하는 것이고, 그러면 회전 행렬이 생깁니다. 여러분은 N, C 알파 및 C 좌표를 사용하여 그람-슈미트 직교화 과정을 사용하여 이것을 수학적으로 정의할 수 있지만, 직관적으로는 C 알파-C 결합을 x축과 정렬하고 이 회전 행렬을 형성하는 것입니다. 따라서 이제 저희는 이 병진 벡터와 이 회전을 기반으로 이 잔기가 3차원 공간 어디에 있는지 알 수 있습니다. 이 잔기가 어떻게 생겼는지, 그리고 이 표현에서 단백질의 일반적인 모양이 어떤지에 대해 질문이 있으신가요? 전역 프레임을 정의할 수 있나요?

모든 잔기에 대해 고정되어 있는 한, 네, 본질적으로 저희는 일반적으로 PDB 파일에서 발견되는 단백질 구조를 가져오고, 이미 어떤 종류의 전역 프레임이 할당되어 있습니다. 좌표가 어디에 있는지 알려주는 방법이 있어야 하고, 단백질 구조에서 가장 중요한 것은 잔기의 상대적인 위치입니다. 따라서 실제 위치와 같은 전역 프레임은 그다지 중요하지 않습니다. 구조 자체와 잔기의 상대적인 위치가 훨씬 더 중요합니다. 하지만 어떤 종류의 전역 프레임을 정의해야 하지만, 정확히 어디에 있어야 하는지는 중요하지 않습니다.

그리고 나중에 중심을 잡음으로써 병진 부분을 우회하는 것을 보게 될 것입니다. 하지만 그것에 대해서는 나중에 다시 이야기하겠습니다. 감사합니다.

좋습니다. 제가 언급했듯이, RF 확산은 RosettaFold를 기반으로 구축되었습니다. RosettaFold가 구조 예측 네트워크라는 것을 모르시는 분들을 위해 설명드리자면, 이 네트워크는 AlphaFold가 출시되기 전에 등장했습니다. 저희는 CASP14의 결과를 보고 놀라움을 금치 못했고, 베이커 연구실의 몇몇 사람들은 "야, 슬라이드에서 이야기하는 것만으로도 이걸 재현할 수 있겠다"라고 생각했습니다. 그래서 그들은 AlphaFold를 재구성하려고 시도했고, 그들의 버전인 RosettaFold는 꽤 잘 작동하며, 심지어 그들의 새로운 버전인 RosettaFold 2는 훨씬 더 좋고 AlphaFold와 동등한 수준입니다. 게다가 단일 모델에서 여러 예측을 수행할 수도 있습니다. 어쨌든, RosettaFold의 구조 예측 부분은 전통적으로 입력 서열을 받습니다. 이것은 여러분이 접으려고 하는 쿼리 서열입니다. 구조 예측은 단백질 서열이 주어졌을 때 그 단백질의 전체적인 접힘 구조가 무엇인지 예측하는 것입니다. 따라서 저희는 구조를 예측하려고 합니다. 그래서 초기 입력 서열을 제공합니다. 이것은 저희가 접으려고 하는 쿼리 단백질의 서열입니다. 또한 그 단백질 서열의 일부 친척도 가지고 있습니다. 이것은 일반적으로 MSA를 형성하고 서열을 기반으로 유사한 알려진 단백질 구조를 찾음으로써 얻습니다. 그리고 저희는 일부 초기 좌표도 가지고 있습니다. 네트워크를 처음 통과할 때는 실제로 모두 원점에 중심을 맞추지만, 재활용(Recycling)은 이것을 변경합니다. 네트워크를 통과하면 결국 좋은 예측 구조를 얻습니다. 구조 생성으로 넘어가서, 이것이 RF 확산입니다. 조금 다릅니다. 제가 언급했듯이, 저희는 단백질 백본을 생성하려고 합니다. 백본이 있으면 실제로 서열이 할당되어 있지 않으므로, 모든 서열은 실제로 마스크 처리됩니다. 저희는 서열 정보를 전혀 모릅니다. Self-conditioning을 사용하여 이 쌍 정보를 업데이트할 수 있습니다. 이에 대해서는 조금 더 자세히 이야기하겠지만, 지금은 모호한 개념으로 남겨두겠습니다. 그리고 XT는 확산된 좌표입니다. 재활용된 좌표를 사용하거나 다른 방식으로 초기화하는 대신, 실제로 이 재활용, 이 확산 궤적에서 이전 좌표를 사용합니다. 그리고 이 모든 정보를 결합하여 이전과 마찬가지로 RosettaFold 2를 통해 처리하면, Ground Truth라고 생각하는 좋은 예측 구조를 얻을 수 있습니다.

자, AR 확산에 대해 좀 더 자세히 살펴보려면, Resold가 어떻게 생겼는지 대략적으로 알아야 합니다. 자세한 내용은 생략하겠지만, 이것이 주요 아키텍처입니다. TTA는 3-트랙 어텐션을 의미합니다. 3-트랙 아키텍처라고 생각하거나, 어쨌든 아키텍처라고 생각합니다. 따라서 여기에는 세 개의 트랙이 있습니다. 하나는 서열용(실제로 다중 서열 트랙, MSA 트랙), 다음은 쌍 트랙, 그리고 3D 트랙입니다. 3D 트랙은 실제 좌표가 조작되는 곳입니다. 그리고 이 트랙들 사이에 많은 상호 통신이 있음을 알 수 있으며, 결국 최종 구조로 정제됩니다. MSA에서 업데이트된 MSA로, MSA와 페어가 서로 통신하고, 페어가 3D 트랙에서 업데이트를 받고, 이전 두 트랙의 모든 정보가 와서 세 번째 트랙(구조-구조 트랙)을 업데이트합니다. 그리고 마지막에는 몇 개의 정제 레이어가 있고, 시작으로 돌아가 재활용을 하기 전에 최종 구조가 있습니다. 이것이 RosettoFold의 일반적인 아키텍처입니다. 자세한 내용을 살펴볼 필요는 없다고 생각하지만, 여기에는 많은 어텐션과 트랜스포머가 있습니다. 제가 언급했듯이, 이것이 RosettaFold 확산 형식의 모습입니다. 따라서 마스크 입력 서열은 첫 번째 트랙을 가져와 MSA 부분을 통과합니다. 백본 생성만 수행하기 때문에 다른 서열은 없습니다. 이 Self-conditioning 행렬(여기서는 모호한 것)은 두 번째 레이어 트랙을 통과하고, 실제로 이동하고 디노이징되는 확산된 좌표는 세 번째 트랙을 통과합니다. 그리고 RF 확산에는 재활용이 없으므로, 이 6은 존재하지 않습니다. 좋습니다. 모델 개요가 어떻게 생겼는지 대략적으로 알았습니다. 단일 단계는 어떻게 수행될까요? 이러한 확산 모델에서는 이 디노이징 궤적에서 많은 단계를 거칩니다. 매우 노이즈가 많은 구조에서 시작하여 점진적으로 디노이징하고, 결국 좋은 결과를 얻습니다. RF 확산의 단일 단계는 다음과 같습니다. 이것을 분해해 보겠습니다. 이 첫 번째 X(T)는 시간 단계 T에서의 노이즈가 있는 좌표가 될 것입니다. 이것은 RosettaFold로 들어가고, RosettaFold는 실제로 디노이징된 구조, 즉 Ground Truth 구조가 어떻게 생겼는지 예측할 것입니다. 따라서 이것은 Xz 예측이 될 것입니다. 그래서 위에 작은 모자가 있고, 그런 다음 이 두 단계를 보간할 것입니다. 따라서 예측된 Ground Truth 구조를 향해 한 걸음 나아가는 것이 본질적으로 이것이 의미하는 바입니다. 이 두 가지 사이의 중간 값을 취하고, 그러면 시간 단계 T-1에서 약간 디노이징된 좌표가 생깁니다. 이전에도 언급했던 부모 트랙에서 이전 예측된 Ground Truth 구조를 사용하는 Self-conditioning 단계도 있습니다. 하지만 이것이 한 단계의 모습이고, 그들은 많은 단계를 함께 묶었습니다. 이러한 단계를 여러 개 연결하면 전체 궤적이 생깁니다. 그리고 이것은 대략 다음과 같습니다. 시간 단계 200에서 시작하여, 이것이 초기 시간 단계가 될 것입니다. 저희는 병진에 대한 가우시안 분포와 균일한 회전을 가지고 있습니다.

이것은 RosettaFold를 통과하고, 저희는 Ground Truth 예측 X(0)를 얻습니다. 이것이 아래에 보이는 모습입니다. 여전히 약간

엉망진창인 스파게티 괴물처럼 보이지만, 모델이 생각하는 Ground Truth의 모습은 대략 이렇습니다. 그래서 다음 단계에 전달하기 위해 실제로 하는 것은 이 두 가지를 보간하는 것입니다. 이 두 가지 구조 사이를 보간하면, 예측된 Ground Truth와 조금 더 비슷하게 보이는 것을 얻습니다.

그러면 이것이 다음 단계로 들어갑니다. 다시 Resold를 통해 처리하면, 단백질과 조금 더 비슷하게 보이는 새로운 Ground Truth 예측을 얻습니다. 하지만 여전히 꽤 스파게티 같습니다. 또 다른 보간 단계를 거칩니다. 이것은 Ground Truth와 조금 더 비슷해 보입니다. 그리고 저희는 계속해서 진행합니다. 결국 여러분이 보게 되는 것은 이러한 Ground Truth 예측이 진행될수록 훨씬 더 단백질처럼 보이고, 이러한 디노이징된 구조는 시간 단계 0, 시간 단계 1까지 진행될수록 Ground Truth와 유사해지기 시작한다는 것입니다. 따라서 이것이 디노이징 단계의 모습, 즉 Retaal 확산의 궤적의 모습입니다. 이 디노이징 과정의 궤적이 어떻게 생겼는지에 대한 개략적인 질문이 있으신가요?

방금 채팅에 하나 올렸는데요. 보간 단계에서 무슨 일이 일어나나요? 제 말은, 실제로 무슨 일이 일어나고 있는 거죠? XTn과 X0 예측 좌표 사이의 평균 같은 건가요?

네, 저희는 SE(3) 다양체 상에서 보간을 수행하고 있습니다. 따라서 올바른 병진 벡터를 향해 한 걸음 나아가고 있습니다. 이것은 본질적으로 Ground Truth 좌표, 최소한 C 알파 좌표를 향한 작은 발걸음과 같습니다. 그리고 회전 행렬도 약간 디노이징합니다. 즉, 노이즈 좌표의 회전 행렬을 예측된 Ground Truth 회전과 약간 정렬하고 있습니다. 그리고 병진 벡터를 가져와서 Ground Truth 예측 병진 벡터처럼 보이도록 약간 이동시키려고 합니다. 지금은 약간 추상적이지만, 논문에 들어가기 전까지는 좀 더 구체적인 세부 사항을 남겨두겠습니다. 왜냐하면 저희는 실제로 몇 가지 공식과 관련 내용을 볼 수 있기 때문입니다. 하지만 그 내용에 대한 약간의 통찰이 되셨기를 바랍니다.

네, 감사합니다. 질문이 있습니다. 이해가 안 되는 것은 Rold가 노이즈가 있는 좌표를 어떻게 가져와서 X 햇 0과 같은 것을 예측하는가입니다. 왜냐하면 아키텍처는 서열을 가져와야 하기 때문입니다. 이전 슬라이드로 돌아가시면...

네, 상동 템플릿인가요? 네, 일종의... 네, 말씀하신 것처럼 서열이 없으므로 서열은 실제로 마스크 처리됩니다. 따라서 여기에는 모든 물음표가 있습니다. 이는 이 초기 서열이 처음에는 MSA 부분을 통과하는 모든 마스크 토큰이라는 의미입니다.

Self-conditioning은 이 쌍 특징으로 들어갑니다. 그래서 제가 언급했듯이, Self-conditioning은 이러한 Ground Truth 예측 구조에서 비롯됩니다. 무슨 일이 일어나고 있냐면, 이 노이즈가 있는 구조를 가져와서 Ground Truth를 예측한 다음, 이 Ground Truth를 가져와서 몇 가지 추가 특징을 계산합니다. 저희는 디스코그램과 일부 앵글그램을 이것으로부터 계산한 다음, 이것을 쌍별 템플릿 특징으로 사용하여 이것을 통과시킵니다. 이것이 Self-conditioning이 실제로 작동하는 방식입니다. 그리고 디노이징된 좌표, 즉 약간 디노이징된 좌표는 임플란트 템플릿 좌표가 될 것입니다.

따라서 저희는 처음에 상동 단백질과 같은 템플릿을 가지고 있지만, Retold 확산에서는 이것이 실제 디노이징되거나 확산된 좌표가 될 것입니다. 따라서 이것들은 저희가 디노이징하려고 하는 노이즈가 있는 좌표입니다. 네, 도움이 되셨기를 바랍니다. 네.

네, 좋습니다. 멋지네요. 네, 이것은 ARS 확산에 대한 개략적인 개요입니다. 그들은 또한 몇 가지 정말 멋진 확장 기능을 개발했습니다. 구조를 생성하는 일반적인 절차는 사전 분포에서 샘플링한 다음, 궤적을 따라 무조건적으로 디노이징하여 단백질처럼 보이는 것을 얻는 것입니다. 이것이 전통적인 방식이지만, ARF 확산을 확장하여 여러 가지 멋진 작업을 수행했습니다. 첫 번째로 한 것은 노이즈를 대칭화하는 것이었습니다. 노이즈 분포를 가져와서 여러 번 복제하면(이 경우 세 번 복제), 대칭 그룹 C3를 사용하여 대칭화합니다. 이것이 C3입니다. 그러면 RF 확산이 대칭적인 알그를 생성할 수 있습니다. 이것들은 z축을 중심으로 정렬되고 대칭화됩니다. 그리고 RF 확산은 그것들을 대칭적으로 디노이징하는 데 꽤 좋은 성능을 보입니다. 그리고 그들이 그것을 어떻게 구체적으로 수행하는지 살펴보겠습니다. 그들은 또한 몇 가지 다른 작업을 수행합니다. 결합 대상이 주어지면 이 대상에 일부 핫팟 잔기를 지정할 수 있으며, 그러면 해당 특정 영역으로 결합체를 확산시킬 수 있습니다. 예를 들어 이 나선과 이 루프 영역을 지정하면, 그것이 해당 영역에 가까워지는 것을 볼 수 있습니다. 모티프 스캐폴딩도 수행할 수 있습니다. 보존하고 싶은 기능성 모티프(이 작은 나선 구조)가 있다면, 나머지 스캐폴드를 확산시킬 수 있습니다. 즉, 해당 모티프를 고정시킨 채로, 그 모티프를 유지할 나머지 단백질을 생성할 수 있습니다.

대칭 모티프 스캐폴딩도 할 수 있습니다. 보존하고 싶은 멋진 대칭 모티프가 있다면, 이것은 모티프 스캐폴딩과 대칭 노이즈를 결합하여 대칭적으로 스캐폴딩하여 그런 단백질을 생성합니다. 논문을 자세히 살펴보면서 이것들의 구체적인 내용을 더 자세히 다룰 수 있기를 바랍니다. 이것들에 대한 개략적인 질문이 있으신가요? 포텐셜과 같은 다른 확장 기능도 있으며, 나중에 이야기하겠습니다.

하지만 이걸로 할 수 있는 멋진 것들이 많이 있습니다. 안녕하세요, 닉. 네. Self-conditioning에서 각 단계별로 어떻게 진행되는지에 대한 일반적인 질문이 있습니다. 원래 예측 구조가 스파게티처럼 보이다가 단계별로 실제 구조처럼 보이게 된다면, 각 단계의 크기는 어느 정도이며, 그 과정은 제어됩니까? 네, 그것은 매우 흥미로운 질문이며, 자세한 내용에 속하기 때문에 제가 분명히 간과한 부분입니다. 나중에 조금 더 자세히 살펴보겠지만, 이 단계들은 비교적 작습니다. 그리고 모델이 훈련된 노이즈 스케일에 따라 달라집니다. 이러한 훈련된 분산 일정에 따라 달라집니다. 나중에 조금 더 자세히 살펴보겠지만, 단계들은 비교적 작습니다. 따라서 여기에서 여기로 이동하는 것을 보면, 이 중간 예측과 그다지 비슷해 보이지 않습니다. 따라서 단계들은 정말 작습니다. 하지만 올바른 모양을 얻는 방법을 알아내려고 노력하는 것입니다. 따라서 많은 단계를 거칩니다. 200단계에서 1단계까지 진행됩니다. 여기로 가기 전에 각인 속도를 높이는 방법이 있으며, 이는 단계 크기를 조정하는 것을 포함합니다. 하지만 나중에 조금 더 자세히 이야기하겠습니다. 죄송하지만 나중으로 미루겠습니다. 감사합니다.

좋습니다. 논문을 실제로 열기 전에 다른 종류의 개략적인 질문이 있으신가요? 좋습니다. 그럼 들어가 보겠습니다.

보충 자료로 전환하겠습니다. 이 방법의 핵심 내용은 모두 여기에 들어 있습니다.

좋습니다. 이 보충 자료에서 가장 먼저 하는 것은 RosettaFold에 대해 이야기하는 것입니다. 왜냐하면 이것이 제가 간략한 개요를 설명한 방식과 매우 유사하기 때문입니다. 그들은 RosettaFold가 어떻게 설정되고 표현되며, 어떻게 훈련되는지에 대해 이야기합니다. 제가 언급했듯이, 그들은 L 잔기의 구조에서 시작하며, 각 잔기는 병진 벡터와 해당 잔기의 회전에 해당합니다. 그리고 그람-슈미트 과정을 사용하여 이것들을 구성할 수 있습니다. 이것이 그 과정과 필요한 공식 및 방정식입니다. 그리고 이러한 일부, 통계 기반의 이상적인 좌표를 가져와서 회전시키고 병진시켜 다른 위치에 있는 이상적인 좌표를 얻음으로써 이상적인 좌표를 재구성할 수 있습니다. 죄송합니다.

네, 죄송합니다. 직접 말씀하시는 건 들리는데, 채팅 내용은 안 들리네요. 하지만 도움이 되셨기를 바랍니다. 네, 죄송합니다. 네, 말씀드렸듯이, 그람-슈미트 과정을 사용하여 회전 행렬을 구성하고, 각 잔기는 회전 벡터와 병진 벡터를 가집니다.

여기 아래로 건너뛰겠습니다. RosettaFold는 제가 언급했듯이 세 개의 트랙과 일부 최종 구조 정제를 가지고 있습니다. 어텐션, SE(3) 등변성 레이어를 기반으로 하며, 좌표를 업데이트합니다. 이것은 여기서 이야기했습니다. 좌표 업데이트 외에도, 곁사슬의 위치와 백본에서 산소를 배치할 위치를 정의하는 일부 비틀림 각도 예측합니다. 따라서 이것은 최종 단백질의 모든 중원자를 실제로 제공할 것입니다. 단량체 예측 외에도, 복합체 예측을 위해 훈련되었습니다. 따라서 위치 인코딩을 사용하여 다량체의 다른 사슬 간의 사슬 끊김을 나타냅니다. 이것은 쌍별 특징 내부에 저장됩니다. 여기에는 모든 특징의 거대한 목록이 있지만,

네, 있습니다. 네, 넘어가겠습니다.

따라서 모든 업데이트는 실제로 어텐션입니다. 저는 그것의 주요 요점만 강조했습니다. 내용이 많아서 다 읽지는 않겠지만, 실제로 어텐션을 사용하여 표현을 업데이트하는 것입니다. 따라서 MSA는 행별 및 열별 어텐션을 사용합니다. 이것은 외적을 기반으로 내용을 업데이트합니다. 이것은 또 다른 축 방향 어텐션이지만, 3D 구조에서 편향 항을 포함합니다. 그리고 SE(3) 트랜스포머를 사용하여 구조를 정제합니다. 이웃이 있는 단백질 그래프를 만들고, 이전 트랙에서 오는 쌍별 특징과 이전 트랙에서 오는 노드 특징을 사용합니다. 이 SE(3) 트랜스포머를 통해 구조를 업데이트하고, 그것이 세 번째 트랙입니다. 그리고 마지막에는 구조 정제인 최종 순방향 레이어가 있습니다. 이것들은 SE(3) 트랜스포머와 동일하지만, 다른 두 트랙은 더 이상 없습니다. 재활용도 있습니다. 따라서 이전 특징이 재활용됩니다. 이것들은 쌍별 특징, MSA 특징, 그리고 최종 예측 구조에서 오는 SE(3) 트랜스포머의 상태 특징입니다. 최종 예측 구조에서 거리 행렬을 만들고, 그것들을 추가적인 쌍별 특징으로 추가합니다. 그리고 몇 번 재활용하며, 훈련 중에 무작위로 샘플링되고, 최종 반복에서만 기울기가 추적되고 역전파됩니다. 이것이 Resold의 개략적인 개요입니다. 그들은 이전에 많은 손실을 가지고 있습니다. 네, 훈련 가능한 가중치는 RosettaFold의 훈련 가능한 가중치가 맞습니까? 네, 그들은 사전 훈련된 RosettaFold 가중치로 시작하여 그 위에 Fine-tuning합니다. 따라서

그리고 손실 전파, 그들은 이 재활용을 하지만, 재활용의 마지막 단계에서만 역전파됩니다. 네, 하지만 재활용은 RosettaFold 훈련에만 관련이 있고, RF 확산에서는 재활용을 하지 않으므로 네트워크를 한 번만 통과합니다. 그리고 손실은 각 시간 단계로 전파되거나, 어떻게 되나요? 네, 하지만 이것은 모든 다른 시간 단계에서 공유되는 가중치입니다. 따라서 어떤 시간 단계에서 노이즈가 있는 구조가 있고, 그 노이즈가 있는 구조와 모든 정보, 그리고 시간 단계를 전달하면, 어떤 종류의 시간 단계 임베딩이 있고, 그런 다음 Ground Truth 구조를 예측합니다. 그것은 네트워크를 한 번만 통과하며, 모든 가중치는 모든 시간 단계에서 공유됩니다. 따라서 훈련 과정에서 무작위로 시간 단계를 샘플링하고, 해당 시간 단계에서 노이즈가 있는 구조를 만든 다음, 그것을 디노이징하려고 합니다. 따라서 모든 가중치는 시간 단계, 예시 등에 걸쳐 공유됩니다. 따라서 손실이 전파되는 모든 경로를 추적하면, 여러분의 다이어그램에서 예측에서 손실로, 그리고 역방향으로 가중치로, RF 확산으로, RosettaFold로 이동합니다. 하지만 그 역방향 경로는 모두 가중치에 대한 공유 기울기를 제공할 것입니다. 따라서 많은 시간 단계로 한 번의 순방향 패스를 수행한 다음, 한 번에 모든 것에 대해 역전파합니다. 네, 네트워크를 통해 실행되는 예시들의 배치가 있습니다. 그들이 실제로 훈련에 사용한 배치 크기를 모르겠지만, 일반적으로 여러 단백질의 배치로 훈련하며, 특정 수준으로 노이즈를 추가하고, 해당 배치에 있는 모든 훈련 예시에 걸쳐 기울기가 누적된 다음 업데이트됩니다.

네, 좋습니다. 따라서 Rapold에 사용된 손실은 RF 확산에 사용된 것과 동일하지 않지만, AlphaFold와 유사한 손실을 사용합니다. 예를 들어, AlphaFold가 도입한 FAPE 손실(Frame Aligned Point Error)은 특정 거리에서 클램핑됩니다. 예측된 비틀림 각에 대한 비틀림 손실도 있습니다. 따라서 저희는 곁사슬 비틀림 각과 오메가, 파이, 사이를 예측했습니다. 굽힘 거리와 방향에 대한 손실도 있고, 최대 언어 모델링과 실험적 예측 정확도도 수행합니다. 이것이 pLDDT가 나오는 곳입니다. 이 예측과 미세 조정에 실제로 사용되는 몇 가지 추가 예측도 있습니다. 방금 빠르게 넘겼지만, 질문이 있으시면 답변해 드릴 수 있습니다. 하지만 R 확산 훈련에 사용된 손실과 동일하지 않기 때문에 빠르게 넘겼습니다. 이에 대해서는 나중에 조금 더 자세히 이야기하겠습니다. 부록 3에는 이러한 손실들이 어떻게 합쳐져 손실 테이블을 형성하는지 나와 있습니다. 네, 보충 자료 45페이지에 있습니다. 네, 바로 거기입니다. 네, 초기 훈련 중에 단백질을 특정 크기로 자릅니다. 배치 크기는 64였습니다. 그들이 사용한 것입니다. 그리고 그들은 이러한 모든 항을 함께 가중치를 부여하고 그렇게 훈련합니다. 미세 조정 중에는 약간 더 큰 크기로 자르고, 반데르발스 항과 같은 더 구체적인 항도 포함하여 훨씬 더 오래 훈련합니다.

네, 제가 언급했듯이, 그들이 훈련에 사용한 데이터 세트에는 단량체, 다량체, 그리고 일부 AlphaFold 2 구조가 포함되어 있습니다. 이것은 AlphaFold가 자체 예측을 사용하여 스스로를 개선한 방식과 유사합니다. 그들은 여기서도 비슷한 방식으로 AlphaFold 예측을 사용하여 RosettaFold를 개선했습니다. 네, 그것이 Rapold의 개요입니다. RF 확산으로 넘어가기 전에 Resold에 대한 질문이 있으신가요? 손실 함수에 대한 가중치를 어떻게 결정하나요? 좋은 질문입니다. 그냥 중요하다고 생각하는 것을 결정하는 것 외에 특정 방법이 있는지 모르겠습니다. 예를 들어, 그들은 FAPE 손실에 매우 큰 가중치를 부여했습니다. 따라서 이것은 각 프레임을 Ground Truth 프레임처럼 보이도록 강하게 제약합니다. 따라서 이것은 매우 중요합니다. 따라서 그들은 비틀림 각에도 큰 가중치를 부여한 것처럼 큰 가중치를 부여했습니다. 이것은 산소의 위치뿐만 아니라 곁사슬을 예측하는 데 매우 중요합니다. 따라서 매우 높은 가중치를 가진 것들은 구조 예측 항입니다. 다른 항들은 더 낮은 가중치를 가집니다. 따라서 이것은 쌍별 표현이 거리 행렬과 각도와 같은 일부 중요한 정보를 포함하도록 돕는 것입니다. 이것은 진화적 역사를 통해 추론하고, 어떤 잔기가 단백질 서열에서 3차원 구조에서 실제로 사용될 수 있는지 파악하려고 노력하는 것입니다. 이것은 PDT에 사용되었으므로, 해당 헤드를 훈련하는 데 사용되었고, 이것도 그냥 네, 따라서 가중치는 적어도 제가 이해한 바로는 대부분 임의적이며, 저도 그렇게 합니다. 하지만 여러분은 가장 관심 있는 것과 모델이 당면한 작업을 배우는 데 가장 좋다고 생각하는 것에 더 높은 가중치를 부여합니다.

네, 감사합니다. 좋습니다. 확산 부분으로 넘어가기 전에 다른 질문이 있으신가요? 좋습니다. 확산으로 들어가 보겠습니다. 확산의 원리에 대한 좋은 개요를 제공합니다. 이전에 이것에 대해 이야기했으므로 빠르게 넘어가겠지만, 가장 중요한 부분에서는 속도를 늦추겠습니다. 이전에도 이야기했듯이, 순방향 확산 과정은 데이터 분포에서 샘플링으로 시작합니다. 이 경우 단백질 백본입니다. 그런 다음 데이터를 손상시켜 노이즈가 있는 구조를 생성합니다. 따라서 이 노이즈 분포를 기반으로 특정 시간 단계에서 많은 노이즈가 있는 구조를 샘플링합니다. 이 노이즈 분포는 이전의 노이즈가 있는 구조에서 노이즈를 축적합니다. 그리고 최종 시간 단계 T에서 참조 분포와 구별할 수 없을 때까지 모든 노이즈를 추가합니다. 이것이 여러분의 사전 분포입니다. 이 경우 병진에 대한 것은 가우시안 분포입니다. 그런 다음 이 역방향 전이 행렬, 즉 커널은 신경망으로 파라미터화됩니다. 그리고 실제로 이러한 모델에서 샘플링하려면, 여기서 사전 분포에서 T에서 샘플을 추출한 다음, 샘플을 반복적으로 디노이징합니다. 따라서 T-1에서 시작하여 데이터 분포처럼 보이는 예시를 얻을 때까지 T로 다시 내려갑니다. 따라서 단백질에 대해 이것을 수행하는 방식은 회전과 병진에 대해 독립적으로 순방향 노이징 과정을 정의하는 것입니다. 제가 언급했듯이, 저희의 단백질 백본은 프레임으로 파라미터화되고, 저희의 프레임은 회전과 병진으로 구성됩니다. 이것은 FrameDiff가 수행한 방식과 매우 유사하지만, 실제로 회전에 대한 확산 과정과 병진에 대한 확산 과정을 독립적으로 수행합니다. 따라서 여기서 보이는 것은 이것이 역방향 단계라는 것입니다. 저희는 T에서 T-1로 이동하고 있으며, 그들은 그것을 독립적으로 파라미터화합니다. 조건부 독립적으로 말입니다. 따라서 이 회전과 이 병진은 서로 독립적입니다.

실제로 잔기 병진, 순방향 및 역방향 병진 또는 확산 궤적을 수행하는 방식은 다음과 같습니다. 제가 말씀드렸듯이 C 알파는 해당 병진 벡터이며, 이것들은 본질적으로 점 클래스로 취급될 것이고, 가우시안 노이즈로 손상시킬 것입니다. 따라서 최소 노이즈에서 최대 노이즈까지 어떤 종류의 분산 일정을 정의하고, 가우시안 프로세스에서 잘 정의되고 잘 특성화된 순방향 프로세스와 같은 것을 갖게 됩니다. 그리고 새로운 노이즈가 있는 병진 벡터는 이전의 덜 노이즈가 있는 샘플에서 이것을 사용하여 샘플링된다고 말할 수 있습니다. 노이즈를 조금 더 추가하고, 평균을 이동시키고, 일부 분산을 추가하면, 조금 더 노이즈가 있고 원래의 가우시안 분포와 조금 더 비슷해 보이는 것을 얻게 됩니다. 따라서 이것이 1까지 계속 증가하면 평균이 없고, 이 베타도 1로 수렴하여 표준 가우시안에서 샘플링하게 될 것입니다. 샘플링을 수행하기 위해 S1에서 St까지 모든 것을 샘플링할 필요는 없습니다. 한계 분포에서 이러한 샘플을 추출합니다. 따라서 C 알파에 대한 실제 좌표가 주어지면 원하는 노이즈가 있는 시간 단계에서 실제로 샘플링할 수 있으며, 이것은 여기의 이 정규 분포를 사용합니다. 그리고 이러한 분산 일정과 관련된 이러한 알파를 사용하여 이것을 정의할 수 있습니다. 따라서 이것은 정말 좋고, 특히 훈련에 유용합니다. 왜냐하면 생성하려는 특정 백본인 단백질 샘플이 주어지면 원하는 시간 단계에서 해당 백본의 노이즈가 있는 버전을 샘플링할 수 있기 때문입니다. 따라서 이것은 훈련에 매우 효율적이며, 알고리즘에서 나중에 이것을 조금 더 자세히 볼 것입니다. 역방향 부분에서는 노이즈가 있는 구조와 Ground Truth가 주어졌을 때 어떤 종류의 디노이징된 구조를 만들고 싶어합니다. 따라서 이것은 일종의 보간입니다. 따라서 이것은 Ground Truth 병진 벡터와 노이즈가 있는 병진 벡터 사이를 보간하는 것입니다. 따라서 그것들을 보간할 것이고, 이 병진, 이것을 평균화된 종류의 평균을 가진 정규 분포를 사용하여 단일 전이로 정의할 수 있습니다. 따라서 예측된 Ground Truth(이것은 z0 햇)를 향해 한 걸음 나아감으로써 디노이징된 구조를 생성합니다. 따라서 이것은 우리가 조금 이야기했던 내용입니다. 데이비드의 질문에 대해 잠깐 언급했습니다. 예측된 Ground Truth의 방향으로 한 걸음 나아가는 것입니다. 이것이 병진으로 그렇게 하는 방법입니다. 회전에 대해서는 약간 다르며, 곧 보게 될 것입니다. 그리고 그들이 병진에 사용한 분산 일정은 선형 분산 일정입니다. 따라서 특정 시간 내에 최소값에서 최대값으로 이동합니다. 그리고 다른 수의 시간 단계를 샘플링하여 추론 속도를 높일 수 있으며, 실제로 분산 일정의 모양을 변경함으로써 이것을 수행할 수 있습니다. 따라서 단계 사이에 추가하는 노이즈의 양은 원하는 시간 단계 수에 따라 적절하게 조정합니다.

음, 좋습니다. 아주 빠르게 병진이 어떻게 작동하는지에 대한 개요를 설명했는데, 회전으로 넘어가기 전에 이에 대한 질문이 있으신가요? 확산 아키텍처에 대해 처음 이야기했을 때, 아키텍처의 핵심 혁신 중 하나는 순방향 노이징 과정을 효율적으로 수행할 수 있는 능력였습니다. 그리고 그것은 가우시안 노이즈를 함께 더하는 이 트릭을 사용할 수 있었기 때문에 가능했습니다. 그렇게 하면 원하는 시간 단계에서 노이즈가 있는 샘플을 생성할 수 있었습니다. 여기서도 그것을 사용하고 있나요? 그리고 그것은 어떻게... 아니면 그렇지 않나요? 어디에서 나타나나요? 네, 그들은 여기서도 정확히 그렇게 합니다.

음, 이것은 여기서 일어납니다. 그래서 그들은... 아, 죄송합니다. 그렇게 하려고 한 게 아니었는데. 음, 그래서 모든 것을 샘플링하는 대신, 실제 Ground Truth 구조가 주어지면 모든 분산을 합산하여 이러한 알파를 만들 수 있으므로 매우 효율적으로 수행합니다. 모든 분산을 연결하거나 큰 곱을 수행하여 알파를 만듭니다. 이것이 샘플링을 수행하는 방법입니다. 이것이 정말 효율적인 샘플링입니다. 따라서 Ground Truth 구조가 주어지면 원하는 시간 단계에서 노이즈가 있는 구조를 샘플링할 수 있으며, 이것이 훈련을 매우 효율적으로 수행할 수 있는 방법입니다. 네, 그들은 분명히 그것을 활용합니다.

그들의 전략이 얼마나 혁신적인지 모르겠습니다. 사전 훈련된 예측기를 사용하는 것이 여기서 꽤 새로운 것인가요, 아니면 다른 곳에서 가져온 아이디어인가요? 음, 솔직히 이 확산에 사전 훈련된 모델, 특히 단백질 구조 예측 모델을 사용하는 다른 방법을 잘 모르겠습니다. 따라서 꽤 새로운 것이라고 생각합니다. 틀릴 수도 있지만, 그렇게 생각합니다.

그리고 얼마나 다른지 궁금합니다. 예를 들어 RF 확산용으로 훈련된 모델을 가져와서 구조 예측만 한다면, 즉 해당 가중치를 RosettaFold처럼 다시 사용한다면 작동할까요? 아니면 완전히 다른 것인가요? 그것이 배우는 것이... 예를 들어, 절제나 미세 조정을 할 수 있는지 모르겠지만, 초기 조건 등 때문에 다소 까다로워집니다. 하지만 RosettaFold 자체적으로 얼마나 좋은가요?

그것은 매우 흥미로운 질문입니다. 잘 모르겠습니다. 제 직관으로는 네트워크에서 쓰레기 같은 결과가 나올 것 같습니다. 왜냐하면 이것들은 특정 목적을 위해 미세 조정되고 훈련되었기 때문입니다. 따라서 서열 정보와 템플릿 정보를 RosettaFold 확산 훈련된 모델에 추가하면 해당 단백질의 구조를 예측하는 데 그다지 좋지 않을 것이라고 생각합니다. 하지만 그것은 우리가 완전히 할 수 있는 일입니다. 예를 들어 각 네트워크에 대한 가중치가 있으므로 예시를 실행할 수 있습니다. 그것은 매우 흥미로운 테스트가 될 것입니다. 누가 했는지 모르겠습니다.

좋습니다. 다른 질문 있으신가요? 네, RF 확산을 훈련할 때, 훈련 중에 SE 정보를 가지고 있나요? 아니요, 기본적으로는 없습니다. 나중에 조금 더 자세히 살펴보겠지만, 그들은 일부 정보에 대해 조건부로 훈련합니다. 예를 들어 모티프 스캐폴딩 문제를 수행하는 경우, 스캐폴딩하려는 모티프의 일부 곁사슬 또는 해당 모티프의 서열 정보가 단백질 생성에 중요할 수 있습니다. RosettaFold에도 서열 트랙이 있으므로 해당 정보를 주입하는 것이 가능합니다. 따라서 그것은 무조건적인 생성에는 수행하지 않지만, 모티프와 활성 부위 생성과 같은 경우에는 분명히 가능합니다.

그렇다면 어떻게... 제 말은, 조금 전에 나왔던 질문으로 돌아가서, 훈련 중에 서열 정보가 없다면, 모델이 어떻게... 제 말은, 손실 함수가 Ground Truth 네이티브 구조에 대한 것이기 때문에, 모델이 서열 없이 네이티브 구조를 예측할 것이라고 어떻게 기대할 수 있습니까? 저희는 백본만 사용하고 있습니다. 그것이 저희가 그렇게 하는 방식입니다. 따라서 기본적으로 PDB에서 백본만 사용하고 있기 때문에, 모든 곁사슬과 모든 서열 정보를 제거하고 백본의 분포를 예측하려고 노력하고 있습니다. 그것이 그들이 그것을 우회하는 방법입니다. 하지만 아마도 정말로 노이즈가 많은 구조에서는 네이티브 구조를 예측할 것으로 기대하지 않고, 아마도 노이즈가 약간만 있는 구조에서만 실제로... 네, 정확히 그렇게 가깝습니다.

여기 잠깐 돌아가겠습니다. 이것이 그것을 강조한다고 생각하기 때문입니다. 아래의 이러한 예측을 보면, 최종 시간 단계에 매우 가까워질 때까지는 실제로 단백질처럼 보이거나 최종 예측 구조와 유사하지 않습니다. 단백질처럼 보이더라도 낮은 손실을 가지려면 이 훈련에 사용된 네이티브 구조처럼 보여야 합니다. 네, 네, 알겠습니다. 감사합니다. 좋습니다. 그럼 회전으로 넘어가겠습니다. 여기가 조금 더 복잡해집니다. FrameDiff에서도 이것을 조금 보았습니다.

하지만 회전은 SO(3)에 존재하며, 이는 3차원 공간의 모든 회전 행렬의 다양체입니다. 그리고 이 다양체에서 브라운 운동을 수행하려면 어떤 종류의 내적을 정의해야 합니다. 따라서 다양체의 접공간에서 수행합니다. 따라서 그들은 여기서 이 내적을 정의합니다. 이것은 실제로 SO(3)의 표준 내적이지만, 프로베니우스 노름의 스케일링입니다. 나중에 조금 더 자세히 살펴보겠습니다. 이 프로베니우스 노름은 실제로 손실 함수에 사용됩니다. 하지만 네, 나중에 조금 더 자세히 살펴보겠습니다. 따라서 그들은 이 접공간에서 어떻게 이동할 수 있는지 정의하는 이 내적을 가지고 있습니다. 그리고

그래서 저는 접공간에 대한 제 생각을 조금이나마 직관적으로 설명하려고 노력하겠습니다. 얼마나 잘 될지는 모르겠지만... 아, 그게 아니었는데.

마음
하지만 저는 s SO3의 다양체나 접공간을 공으로 생각하는 것을 좋아합니다. 그리고 만약 여러분이
해석하다
그리는 방법을 찾는 데 정말 애먹고 있습니다.
그리다... 아마 건너뛸 것 같습니다. 모르겠네요. 아, 아마 줌 드로우를 사용할 수 있을 것 같습니다. 네, 줌을 사용하여 그리겠습니다. 따라서 3차원에 이 구가 있습니다. 이것이 SO3 다양체를 나타냅니다. 그리고 회전 행렬에 대해 다른 표현을 사용하면 이것을 할 수 있습니다. 왜냐하면 저희는 회전 행렬을 오일러 축, 즉 축-각 표현으로 나타낼 수 있기 때문입니다. 원점이라면 구의 표면으로 가는 벡터를 정의할 수 있으며, 그것은 저희가 회전하는 축을 나타낼 수 있습니다. 따라서 이것은 구 위의 점을 나타내고, 구 위를 이동하면 저희가 회전하는 다양한 각도나 축을 얻을 수 있습니다. 저희는 접공간을 정의할 수 있습니다. 그것은 실제로 이 다양체의 접선의 일반화와 같습니다. 그것은 평면처럼 보일 것입니다. 따라서 저희는 저희의 공 위에 놓인 판지와 같은 것을 가질 것입니다. 그리고 이것이 이 점에서 저희의 접공간이 될 것입니다. 그리고 이 접공간에서 이동하는 방법을 정의해야 합니다. 따라서 이것이 브라운 운동이 나오는 곳입니다. 그리고 그들이 실제로 이것을 수행하는 방식은 이 아이소갈란을 사용하여 이 접공간에서 이 브라운 운동을 파라미터화하는 것입니다. SO3 분포입니다. 그리고 그것은 초기 회전과 시간 단계 T로 파라미터화됩니다. 그리고 이것에서 샘플링함으로써 SO3에서 정말 좋은 균일 분포를 얻을 수 있습니다. 따라서 이것은 이 무한 급수를 가진 복잡한 공식이지만, 나중에 보게 될 점수 근사에 사용되기 때문에 그냥 넘어가겠습니다. 하지만 이것은 잘라내야 합니다. 왜냐하면 무한하기 때문입니다. 하지만 그들은 이것을 사용하여 접공간에서 이동해야 하는 위치를 계산하는 데 도움을 받습니다. 따라서 저희는 이 판지 조각 위에 있고, 그 판지 위에서 어떤 방향으로 이동합니다. 그리고 일단 그 방향으로 이동하면... 죄송합니다. 다시 그리겠습니다.

음, 안 돼.
음... 좋아... 음... 저희는... 저희는 공, 저희의 SO3를 가지고 있습니다. 어떤 위치에 접공간이 있습니다.
여기
일단 이 접공간에서 가야 할 방향으로 한 걸음 내딛으면, 저희는 더 이상 공 위에 있지 않습니다. 그것은 문제입니다. 저희는 이 다양체 위에 남아 있어야 합니다. 만약 그것이 현실적인 회전 행렬처럼 되기를 원한다면, 그들이 이것을 수행하는 방식은 측지 랜덤 워크를 사용하는 것입니다. 일단 저희가 이 가야 할 방향을 가지면, 그것을 다시 구부려 다양체 위에 다시 놓을 수 있습니다. 따라서 이제 저희는 이 방향으로 다시 여기에 있을 것입니다. 따라서 저희는 접공간에서 작은 발걸음을 내딛고, 이제 저희는 다양체를 떠나고, 그런 다음 이것을 구부려 다양체로 다시 가져옵니다. 그리고 이제 저희는 이 다양체에서 적어도 구 위에 있기 때문에 약간 곡선처럼 보이는 곡선 방향을 가지게 됩니다. 약간 추상적이었지만, 그것이 다소 명확했기를 바랍니다. 하지만 네, 저희는 이 아이소갈란을 가지고 있습니다. 이 아이소갈란 SO3 분포, 즉 한계 분포에서 샘플링하여 순방향 운동을 수행할 수 있습니다. 그리고 이것이 여기서 정말 중요한 점이라고 생각합니다. 따라서 제가 언급했듯이 병진은 시간 단계가 증가함에 따라 가우시안 분포로 수렴합니다. 그러나 회전은 S SO3의 균일 분포로 수렴합니다. 따라서 최종 시간 단계 T에서 그 공 위에 분포를 가지게 되며, 그 공 위에서 완전히 균일합니다. 따라서 다른 회전 축과 마찬가지로 어떤 회전 축도 샘플링될 가능성이 동일합니다. 이것은 스케일링 분포와 약간 다릅니다. 왜냐하면 이것은 다른 곳보다 0 주변에서 훨씬 더 많이 샘플링될 것이기 때문입니다.

음, 제가 언급했듯이, 회전 업데이트에 대한 역방향 단계에서는 SO3 접공간에서 노이즈가 있는 단계를 거쳐야 합니다. 따라서 판지 위에서 한 걸음 내딛지만, 공을 떠났으므로 공으로 다시 투영해야 합니다. 따라서 이 지수 맵을 사용하여 S SO3 다양체로 다시 투영합니다. 그리고 그것은 나중에 나타납니다. 따라서 제가 측지 랜덤 워크를 언급했는데, 이것이 접공간에서

S SO3 다양체로 다시 매핑하는 방법입니다. 따라서 이것이 여기서 가장 중요한 양입니다. 실제로 이것이 접공간에서 이동해야 하는 방향입니다. 따라서 이 경우 이것이 노이즈가 있는 회전에서 데이터 회전처럼 보이는 것으로 이동하는 방법입니다. 그리고 이 항은 실제로 약간의 추가 노이즈를 추가하는 것입니다. 따라서 이것은 브라우니안 운동 부분을 처리하는 것입니다. 아, 제가 뭔가 잘못했어요. 그런 일이 가능한지 몰랐어요. 따라서 이것이 브라우니안 운동 부분입니다. 그리고 회전으로 돌아가기 위해 이 지수 맵을 사용합니다. 따라서 네, 이것이 스타인 점수, 점수 매칭의 점수 매칭 부분입니다. 그리고 저희는 접공간에서, 즉 판지 조각에서 공으로 가는 지수 맵을 가지고 있습니다. 그리고 네, 이것이 회전에 대한 순방향 및 역방향 궤적을 정의하는 방법입니다. 그리고 이것은 선형 스케줄이 아닌 다른 스케줄, 즉 이차 스케줄을 사용합니다. 하지만 다시 말하지만, 그것은 하이퍼파라미터일 뿐입니다. 따라서 이 실제 역방향 궤적을 학습하는 것은 점수 매칭을 사용하여 가능하며, 이것은 FrameDiff에서 수행됩니다. 이것은 매우 이론적인 방법입니다. 하지만 그들은 구조 예측 능력을 실제로 활용하는 근사를 원했습니다. 따라서 RosettaFold는 구조 예측에 매우 능숙합니다. 따라서 해당 능력을 사용하여 확산을 발전시킬 수 있을까요? 그들이 그렇게 하는 방식은 여기서 이 근사를 형성하는 것입니다. 따라서 저희가 실제로 관심 있는 점수는...

죄송합니다. 야생형 Ground Truth 구조에서 노이즈가 있는 구조로 이동하는 점수입니다. 따라서 이것이 Ground Truth 구조로 이동하고 싶은 방향입니다. 적어도 이 부분에서는 회전에만 관심이 있습니다. 따라서 여기서 회전만 사용하겠습니다. Ground Truth 회전을 사용하여 이것을 근사할 수 있습니다. 이것은 Ground Truth 또는 예측된 Ground Truth 회전입니다. 죄송합니다. 따라서 이것은 RosettaFold에서 나오는 것입니다. 그리고 이것을 사용하여 점수를 근사할 수 있습니다. 그리고 이것은 아이소갈란을 사용하는 것과 같습니다. RosettaFold에서 예측된 회전을 사용하는 것과 같습니다. 따라서 이것이 RosettaFold의 Ground Truth 구조 예측 능력을 디노이징 궤적에 사용할 수 있는 점수를 근사하는 방식으로 활용하는 방법입니다. 따라서 이 근사를 얻으면 이 방정식에 넣거나, 실제로 위에서 사용한 멱급수에서 해당 방정식을 쓸 수 있습니다.

음... 그래요. 매우 추상적이었어요.
음... 네.
음, 실제로 역과정에서 회전을 수행하는 방식은 방향으로 단계를 취한 다음, 실제로 회전시키는 것입니다. 이전 위치를 이 추가 회전, 즉 여러분이 만들고 있는 이 단계만큼 회전시키면, 약간 디노이징된 구조를 얻게 됩니다. 그리고 네, 여기서 이 근사를 볼 수 있습니다. 그들은 멱급수를 근사하고, 그런 다음 예측된 회전을 취하고 이러한 모든 큰 방정식을 사용하여 점수 근사를 계산함으로써 이동해야 하는 방향, 즉 단계를 근사할 수 있습니다.

그들은 그것을 정당화하는 데 도움이 되는 몇 가지 증명을 합니다. 네, 그것이 순방향 및 역방향 병진 확산의 회전 과정에 대한 개략적인 개요입니다. 이에 대한 질문이 있으신가요? 음, RFD Fusion과 Friend Diff의 주요 차이점은 RFD Fusion이 RosettaFold에서 예측한 구조를 손실을 계산할 때 Ground Truth 구조로 사용한다는 것인가요? 아니면... 알겠습니다. 그리고 Friend에서는 그냥 Ground Truth를 사용하나요? 네, 그래서 RosettaFold에서는, 또는 RF 확산에서는 Ground Truth 구조를 예측한 다음, 그것을 디노이징하기 위한 노이즈가 있는 보간을 역계산합니다. 제가 말하고 싶은 다른 주요 차이점은 손실 함수입니다.

음, RF 확산은 실제로 디노이징 점수 손실을 사용하지 않습니다. 실제로 MSC 손실을 사용하는데, 이것은 디노이징 궤적의 경험적 근사치와 같습니다. 따라서 이것이 여기서 나타나는 곳입니다. 이 평균 제곱 오차 손실입니다. 따라서 그들은 실제로 여기서 병진과 여기서 회전에 대해 이 평균 제곱 오차 손실을 수행합니다. 그리고 이것이 제가 생각하는 주요 차이점이 나오는 곳입니다. 확산에 사전 훈련된 구조 예측 네트워크를 사용하는 것 외에도, 이것이 다른 주요 차이점입니다. 아키텍처 외에도 말이죠. 하지만 이 손실 함수는 실제로 이론에 그다지 기반을 두지 않습니다. 하지만 여기서 조금 더 아래에서 설명하는 몇 가지 정당성이 있습니다. 따라서 가우시안일 때는 이 KL 발산을 예측의 예상 오차와 노이즈가 있는 관측값을 사용하여 재조정할 수 있습니다. 이것은 매우 쉽고, 이것은 추가된 노이즈 또는 이동해야 하는 점수를 근사하는 것과 같습니다. 그리고 이것은 가우시안 노이즈를 사용할 때 정말 잘 작동하고 정당화됩니다. 하지만 회전의 경우 이것은 완전히 정당화되지 않습니다. 아이소갈란 SO3에는 적용되지 않을 가능성이 높지만, 사용하는 것이 꽤 합리적이며, 그들은 여기서 그것을 정당화합니다. 따라서 이 손실 함수는 또한 그것을 차별화하는 방식입니다. 조금 도움이 되었기를 바랍니다. 그리고 시간이 다 된 것도 압니다.

음... 필요하시면 나가셔도 됩니다. 더 이야기하고 싶으시면 남아 계셔도 됩니다. 하지만 닉, 이렇게 멋지고 자세한 개요를 해주셔서 감사합니다. 벤치마킹 측면에서 RF 확산이 얼마나 잘 작동하는지, 그리고 커뮤니티의 많은 사람들이 자신의 특정 작업에 적용해 왔다는 것을 알고 있기 때문에 놀라울 정도로 생산적입니다. 정확히 비법이 무엇인지 알기 어렵고, FrameDiff처럼 관련 아키텍처를 탐색하는 것은 정말 재미있을 것입니다. 하지만 다른 것들도 나오고 있어서, 어떤 부분이... 무엇이 이토록 특별하게 작동하게 만드는 마법의 비법인지 파악하려고 노력할 것입니다. 앞으로 나아가면서 더 많이 탐구할 것은 사전 훈련인지, 확산인지, 이러한 다양한 손실의 조합인지, 데이터인지, 어떤 측면이 정말로 정말로 필수적인지일 것입니다. 시간이 다 되었지만... 음... 이 독서 그룹이 재미있었다고 생각합니다. 저는 확실히 많은 것을 배웠습니다. 구조나 조직 방식에 대한 다른 피드백이 있다면 알려주시면 저희가 조정할 수 있습니다. 그렇지 않으면 2주 후에 뵙기를 바랍니다. 그리고 그렇지 않으면 안전하게 공부하세요. 모두 감사합니다. 감사합니다.

